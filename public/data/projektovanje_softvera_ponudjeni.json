[
  {
    "id": 1,
    "question": "Šta je softverski sistem?",
    "answers": [
      "Softverski sistem je sistem međusobno povezanih komponenti zasnovanih na softveru koji čini deo računarskog sistema (kombinacija hardvera i softvera). On se sastoji od većeg broja zasebnih programa, konfiguracionih fajlova, koji se koriste za podešavanje ovih programa, sistemske dokumentacije, koja opisuje strukturu sistema, i koriničke dokumentacije, koja objašnjava kako se sistem koristi.",
      "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike. Sastoje se iz tri dela: dela za komunikaciju sa klijentom, dela za komunikaciju sa bazom i dela koji sadrži poslovnu logiku.",
      "Aplikaciona logika opisuje strukturu i ponašanje sistema. Sastoji se od kontrolera aplikacione logike, poslovne logike (domenske klase i sistemske operacije) i brokera baze podataka.",
      "Softverski sistem se sastoji od atributa i sistemskih operacija. Atributi opisuju strukturu sistema, dok sistemske operacije opisuju ponašanje sistema."
    ],
    "correctAnswer": "Softverski sistem je sistem međusobno povezanih komponenti zasnovanih na softveru koji čini deo računarskog sistema (kombinacija hardvera i softvera). On se sastoji od većeg broja zasebnih programa, konfiguracionih fajlova, koji se koriste za podešavanje ovih programa, sistemske dokumentacije, koja opisuje strukturu sistema, i koriničke dokumentacije, koja objašnjava kako se sistem koristi."
  },
  {
    "id": 2,
    "question": "Od čega se sastoji softverski sistem?",
    "answers": [
      "Softverski sistem se sastoji od atributa i sistemskih operacija. Atributi opisuju strukturu sistema, dok sistemske operacije opisuju ponašanje sistema.",
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza). Pravila: AL nezavisna od KI; AL može imati više KI; Model ne zna za View.",
      "Od skupa slučajeva korišćenja (SK), aktora (AK) и veza između slučajeva korišćenja i aktora.",
      "Softverski sistem se sastoji od većeg broja zasebnih programa, konfiguracionih fajlova i dokumentacije koja opisuje strukturu sistema."
    ],
    "correctAnswer": "Softverski sistem se sastoji od atributa i sistemskih operacija. Atributi opisuju strukturu sistema, dok sistemske operacije opisuju ponašanje sistema."
  },
  {
    "id": 3,
    "question": "Šta su atributi softverskog sistema?",
    "answers": [
      "Sistemske operacije opisuju ponašanje sistema i predstavljaju osnovne (atomske) funkcije sistema koje se mogu koristiti iz okruženja sistema.",
      "Dopustivi ulaz u softverski sistem je definisan potpisom (signaturom), koji sadrži naziv sistemske operacije koja se poziva i skupom ulaznih argumenata.",
      "Softverski sistem se sastoji od atributa i sistemskih operacija. Atributi opisuju strukturu sistema",
      "Izlaz iz softverskog sistema je predstavljen preko skupa izlaznih argumenata. Izlaz se dobija kao rezultat izvršenja neke od sistemskih operacija nad atributima sistema."
    ],
    "correctAnswer": "Softverski sistem se sastoji od atributa i sistemskih operacija. Atributi opisuju strukturu sistema"
  },
  {
    "id": 4,
    "question": "Sistemske operacije",
    "answers": [
      "Sistemske operacije opisuju ponašanje sistema i predstavljaju osnovne (atomske) funkcije sistema koje se mogu koristiti iz okruženja sistema.",
      "Softverski sistem se sastoji od atributa i sistemskih operacija. Atributi opisuju strukturu sistema",
      "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora.",
      "Aktor izvodi: APUSO (Aktor Priprema Ulaz za Sistemsku Operaciju), APSO (Aktor Poziva Sistemsku Operaciju), ANSO (Aktor izvršava NeSistemsku Operaciju)."
    ],
    "correctAnswer": "Sistemske operacije opisuju ponašanje sistema i predstavljaju osnovne (atomske) funkcije sistema koje se mogu koristiti iz okruženja sistema."
  },
  {
    "id": 5,
    "question": "Dopustivi ulazi u softverski sistem",
    "answers": [
      "Dopustivi ulaz u softverski sistem je definisan potpisom (signaturom), koji sadrži naziv sistemske operacije koja se poziva i skupom ulaznih argumenata.",
      "Izlaz iz softverskog sistema je predstavljen preko skupa izlaznih argumenata. Izlaz se dobija kao rezultat izvršenja neke od sistemskih operacija nad atributima sistema.",
      "Ugovori opisuju šta operacija treba da radi. Sekcije: Operacija, Veza sa SK, Preduslov (stanje pre izvršenja), Postuslov (stanje posle izvršenja).",
      "Aktor izvodi: APUSO (Aktor Priprema Ulaz za Sistemsku Operaciju), APSO (Aktor Poziva Sistemsku Operaciju), ANSO (Aktor izvršava NeSistemsku Operaciju)."
    ],
    "correctAnswer": "Dopustivi ulaz u softverski sistem je definisan potpisom (signaturom), koji sadrži naziv sistemske operacije koja se poziva i skupom ulaznih argumenata."
  },
  {
    "id": 6,
    "question": "Šta je izlaz iz softverskog sistema?",
    "answers": [
      "Dopustivi ulaz u softverski sistem je definisan potpisom (signaturom), koji sadrži naziv sistemske operacije koja se poziva i skupom ulaznih argumenata.",
      "Izlaz iz softverskog sistema je predstavljen preko skupa izlaznih argumenata. Izlaz se dobija kao rezultat izvršenja neke od sistemskih operacija nad atributima sistema.",
      "Vrednosna ograničenja se odnose na dozvoljene vrednosti atributa (prosta i složena). Strukturna ograničenja su definisana kardinalnostima preslikavanja.",
      "Softverski sistem se sastoji od atributa i sistemskih operacija. Atributi opisuju strukturu sistema"
    ],
    "correctAnswer": "Izlaz iz softverskog sistema je predstavljen preko skupa izlaznih argumenata. Izlaz se dobija kao rezultat izvršenja neke od sistemskih operacija nad atributima sistema."
  },
  {
    "id": 7,
    "question": "Uprošćena Larmanova metoda i faze razvoja softvera",
    "answers": [
      "Faza analize opisuje logičku strukturu i ponašanje softverskog sistema (poslovnu logiku). Struktura se opisuje pomoću konceptualnog i relacionog modela.",
      "Arhitektura softverskog sistema (tronivojska), definisane komponente, interfejsi, ekranske forme, detaljno projektovanje klasa i baze podataka.",
      "Razvoj (životni ciklus) softverskog sistema se sastoji iz sledećih faza (Slika RASS): Prikupljanja zahteva od korisnika, Analize, Projektovanja, Implementacije, Testiranja.",
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza)."
    ],
    "correctAnswer": "Razvoj (životni ciklus) softverskog sistema se sastoji iz sledećih faza (Slika RASS): Prikupljanja zahteva od korisnika, Analize, Projektovanja, Implementacije, Testiranja."
  },
  {
    "id": 8,
    "question": "Šta su funckionalni i nefunkcionalni zahtevi?",
    "answers": [
      "U FURPS+ modelu znak '+' ukazuje na pomoćne zahteve koji se odnose na: Implementaciju, Interfejs, Operacije, Pakovanje, Legalnost.",
      "Pouzdanost predstavlja sposobnost sistema da može uspešno obraditi problem (failure) koji se dešava u toku izvršenja sistema.",
      "Funkcionalni zahtevi definišu zahtevane funkcije sistema, dok nefunkcionalni zahtevi definišu sve ostale zahteve. Nefunkcionalni zahtevi kao što su upotrebljivost, pouzdanost, performanse i podrživost sistema predstavljaju atribute kvaliteta softverskog sistema. Funkcionalni zahtevi se opisuju preko modela slučaja korišćenja.",
      "Faza analize opisuje logičku strukturu i ponašanje softverskog sistema (poslovnu logiku). Struktura se opisuje pomoću konceptualnog i relacionog modela."
    ],
    "correctAnswer": "Funkcionalni zahtevi definišu zahtevane funkcije sistema, dok nefunkcionalni zahtevi definišu sve ostale zahteve. Nefunkcionalni zahtevi kao što su upotrebljivost, pouzdanost, performanse i podrživost sistema predstavljaju atribute kvaliteta softverskog sistema. Funkcionalni zahtevi se opisuju preko modela slučaja korišćenja."
  },
  {
    "id": 9,
    "question": "Šta predstavlja FURPS+ model?",
    "answers": [
      "Funkcionalni zahtevi definišu zahtevane funkcije sistema, dok nefunkcionalni zahtevi definišu sve ostale zahteve.",
      "U FURPS+ modelu znak '+' ukazuje na pomoćne zahteve koji se odnose na: Implementaciju, Interfejs, Operacije, Pakovanje, Legalnost. (F-Functional, U-Usability, R-Reliability, P-Performance, S-Supportability).",
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza).",
      "Pouzdanost predstavlja sposobnost sistema da može uspešno obraditi problem (failure) koji se dešava u toku izvršenja sistema."
    ],
    "correctAnswer": "U FURPS+ modelu znak '+' ukazuje na pomoćne zahteve koji se odnose na: Implementaciju, Interfejs, Operacije, Pakovanje, Legalnost. (F-Functional, U-Usability, R-Reliability, P-Performance, S-Supportability)."
  },
  {
    "id": 10,
    "question": "Pouzdanost održivog softverskog sistema",
    "answers": [
      "Funkcionalni zahtevi definišu zahtevane funkcije sistema, dok nefunkcionalni zahtevi definišu sve ostale zahteve.",
      "U FURPS+ modelu znak '+' ukazuje na pomoćne zahteve koji se odnose na: Implementaciju, Interfejs, Operacije, Pakovanje, Legalnost.",
      "Stanje u kome je sve u skladu sa strukturnim ograničenjima.",
      "Pouzdanost predstavlja sposobnost sistema da može uspešno obraditi problem (failure) koji se dešava u toku izvršenja sistema. U tom smislu sistem mora da obezbedi način oporavka (recoverability) podataka u slučaju nasilnog prekida rada sistema. Takođe sistem treba da omogući predviđanje (predictability) mogućih ponašanja sistema."
    ],
    "correctAnswer": "Pouzdanost predstavlja sposobnost sistema da može uspešno obraditi problem (failure) koji se dešava u toku izvršenja sistema. U tom smislu sistem mora da obezbedi način oporavka (recoverability) podataka u slučaju nasilnog prekida rada sistema. Takođe sistem treba da omogući predviđanje (predictability) mogućih ponašanja sistema."
  },
  {
    "id": 11,
    "question": "Objasniti model slučajeva korišćenja, šta opisuje SK, šta opisuje jedan scenario SK",
    "answers": [
      "Aktor (učesnik) predstavlja spoljnog korisnika sistema koji postavlja zahtev sistemu. Osnovni scenario opisuje tipičan uspeh, dok alternativni scenariji opisuju ređe situacije ili greške.",
      "Tekstualni opis SK ima strukturu: Naziv SK, Aktore SK, Učesnike SK, Preduslovi, Osnovni scenario, Postuslovi, Alternativna scenarija, Specijalni zahtevi, Tehnološki zahtevi, Otvorena pitanja.",
      "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora. Scenario opisuje jedno željeno korišćenje sistema od strane aktora. Scenario je opisan preko: a) sekvence akcija i b) interakcija između aktora i sistema.",
      "Od skupa slučajeva korišćenja (SK), aktora (AK) и veza između slučajeva korišćenja i aktora."
    ],
    "correctAnswer": "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora. Scenario opisuje jedno željeno korišćenje sistema od strane aktora. Scenario je opisan preko: a) sekvence akcija i b) interakcija između aktora i sistema."
  },
  {
    "id": 12,
    "question": "Tipovi akcija koje izvodi aktor (APSO, IA, ANSO)",
    "answers": [
      "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora.",
      "Aktor (učesnik) predstavlja spoljnog korisnika sistema koji postavlja zahtev sistemu. Osnovni scenario opisuje tipičan uspeh, dok alternativni scenariji opisuju ređe situacije ili greške.",
      "Tekstualni opis SK ima strukturu: Naziv SK, Aktore SK, Učesnike SK, Preduslovi, Osnovni scenario, Postuslovi, Alternativna scenarija, Specijalni zahtevi, Tehnološki zahtevi, Otvorena pitanja.",
      "Aktor izvodi: APUSO (Aktor Priprema Ulaz za Sistemsku Operaciju), APSO (Aktor Poziva Sistemsku Operaciju), ANSO (Aktor izvršava NeSistemsku Operaciju). Sistem izvodi: SO (Sistem izvršava Sistemsku Operaciju), IA (Izlazni Argumenti se prosleđuju aktoru)."
    ],
    "correctAnswer": "Aktor izvodi: APUSO (Aktor Priprema Ulaz za Sistemsku Operaciju), APSO (Aktor Poziva Sistemsku Operaciju), ANSO (Aktor izvršava NeSistemsku Operaciju). Sistem izvodi: SO (Sistem izvršava Sistemsku Operaciju), IA (Izlazni Argumenti se prosleđuju aktoru)."
  },
  {
    "id": 13,
    "question": "Definicije aktora, osnovnog scenaria, alternativnog scenaria",
    "answers": [
      "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora.",
      "Aktor (učesnik) predstavlja spoljnog korisnika sistema koji postavlja zahtev sistemu. Osnovni scenario opisuje tipičan uspeh, dok alternativni scenariji opisuju ređe situacije ili greške. Slučaj korišćenja ima jedan glavni i više alternativnih scenarija.",
      "Aktor izvodi: APUSO (Aktor Priprema Ulaz za Sistemsku Operaciju), APSO (Aktor Poziva Sistemsku Operaciju), ANSO (Aktor izvršava NeSistemsku Operaciju).",
      "Od skupa slučajeva korišćenja (SK), aktora (AK) и veza između slučajeva korišćenja i aktora."
    ],
    "correctAnswer": "Aktor (učesnik) predstavlja spoljnog korisnika sistema koji postavlja zahtev sistemu. Osnovni scenario opisuje tipičan uspeh, dok alternativni scenariji opisuju ređe situacije ili greške. Slučaj korišćenja ima jedan glavni i više alternativnih scenarija."
  },
  {
    "id": 14,
    "question": "Glass's law",
    "answers": [
      "Nedostaci kod definisanja zahteva su osnovni razlog mogućeg neuspeha u razvoju projekta (programa).",
      "Ukoliko se ne uoče greške u toku definisanja zahteva, iste se veoma teško mogu ukloniti u kasnijim fazama razvoja programa.",
      "Pravljenje prototipova značajno smanjuje moguće greške kod definisanja zahteva i njegovog razvoja, naročito kod definisanja korisničkog interfejsa.",
      "Scenarija slučajeva korišćenja ne treba da budu u međussobnoj interakciji. Ona se treba definisati kao atomska, u smislу da se izvršavaju u potpunosti samostalno. Na taj način se olakšava njihov razvoj i održavanje."
    ],
    "correctAnswer": "Nedostaci kod definisanja zahteva su osnovni razlog mogućeg neuspeha u razvoju projekta (programa)."
  },
  {
    "id": 15,
    "question": "Boehm's first and second law",
    "answers": [
      "Nedostaci kod definisanja zahteva su osnovni razlog mogućeg neuspeha u razvoju projekta (programa).",
      "Ukoliko se ne uoče greške u toku definisanja zahteva, iste se veoma teško mogu ukloniti u kasnijim fazama razvoja programa.",
      "Pravljenje prototipova značajno smanjuje moguće greške kod definisanja zahteva i njegovog razvoja, naročito kod definisanja korisničkog interfejsa.",
      "Scenarija slučajeva korišćenja ne treba da budu u međussobnoj interakciji. Ona se treba definisati kao atomska, u smislу da se izvršavaju u potpunosti samostalno. Na taj način se olakšava njihov razvoj i održavanje."
    ],
    "correctAnswer": [
      "Ukoliko se ne uoče greške u toku definisanja zahteva, iste se veoma teško mogu ukloniti u kasnijim fazama razvoja programa.",
      "Pravljenje prototipova značajno smanjuje moguće greške kod definisanja zahteva i njegovog razvoja, naročito kod definisanja korisničkog interfejsa."
    ]
  },
  {
    "id": 16,
    "question": "Kako se tekstualno predstavlja slučaj korišćenja?",
    "answers": [
      "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora.",
      "Ugovori opisuju šta operacija treba da radi. Sekcije: Operacija, Veza sa SK, Preduslov (stanje pre izvršenja), Postuslov (stanje posle izvršenja).",
      "Od skupa slučajeva korišćenja (SK), aktora (AK) и veza između slučajeva korišćenja i aktora.",
      "Tekstualni opis SK ima strukturu: Naziv SK, Aktore SK, Učesnike SK, Preduslovi, Osnovni scenario, Postuslovi, Alternativna scenarija, Specijalni zahtevi, Tehnološki zahtevi, Otvorena pitanja."
    ],
    "correctAnswer": "Tekstualni opis SK ima strukturu: Naziv SK, Aktore SK, Učesnike SK, Preduslovi, Osnovni scenario, Postuslovi, Alternativna scenarija, Specijalni zahtevi, Tehnološki zahtevi, Otvorena pitanja."
  },
  {
    "id": 17,
    "question": "Konceptualno da se objasni sta se radi u fazi analize i šta je rezultat faze analize",
    "answers": [
      "Arhitektura softverskog sistema (tronivojska), definisane komponente, interfejsi, ekranske forme, detaljno projektovanje klasa i baze podataka.",
      "Razvoj (životni ciklus) softverskog sistema se sastoji iz sledećih faza (Slika RASS): Prikupljanja zahteva od korisnika, Analize, Projektovanja, Implementacije, Testiranja.",
      "Na osnovu konceptualnog modela pravi se relacioni model (baza podataka). Primer: Klasa Racun postaje tabela Racun, Klasa StavkaRacuna postaje tabela StavkaRacuna sa stranim ključem ka Racunu.",
      "Faza analize opisuje logičku strukturu i ponašanje softverskog sistema (poslovnu logiku). Struktura se opisuje pomoću konceptualnog i relacionog modela. Ponašanje se opisuje pomoću sistemskih dijagrama sekvenci i sistemskih operacija. Rezultat su: dijagram klasa (konceptualni model), relacioni model, dijagrami sekvenci i ugovori sistemskih operacija."
    ],
    "correctAnswer": "Faza analize opisuje logičku strukturu i ponašanje softverskog sistema (poslovnu logiku). Struktura se opisuje pomoću konceptualnog i relacionog modela. Ponašanje se opisuje pomoću sistemskih dijagrama sekvenci i sistemskih operacija. Rezultat su: dijagram klasa (konceptualni model), relacioni model, dijagrami sekvenci i ugovori sistemskih operacija."
  },
  {
    "id": 18,
    "question": "Sekvencni dijagrami da se objasne",
    "answers": [
      "Ugovori opisuju šta operacija treba da radi. Sekcije: Operacija, Veza sa SK, Preduslov (stanje pre izvršenja), Postuslov (stanje posle izvršenja).",
      "Koristi se za modelovanje dinamičkog ponašanja objekta. Prikazuje stanja kroz koja objekat prolazi tokom svog životnog ciklusa kao odgovor na događaje.",
      "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih.",
      "Sistemski dijagram sekvenci prikazuje, za izdvojeni scenario SK, događaje u određenom redosledu, koji uspostavljaju interakciju između aktora i softverskog sistema. Dobijaju se na osnovu scenarija SK (samo APSO i IA akcije)."
    ],
    "correctAnswer": "Sistemski dijagram sekvenci prikazuje, za izdvojeni scenario SK, događaje u određenom redosledu, koji uspostavljaju interakciju između aktora i softverskog sistema. Dobijaju se na osnovu scenarija SK (samo APSO i IA akcije)."
  },
  {
    "id": 19,
    "question": "Sistemske operacije (preduslovi, postuslovi) i ugovori za sistemske operacije",
    "answers": [
      "Sistemski dijagram sekvenci prikazuje, za izdvojeni scenario SK, događaje u određenom redosledu, koji uspostavljaju interakciju između aktora i softverskog sistema.",
      "Tekstualni opis SK ima strukturu: Naziv SK, Aktore SK, Učesnike SK, Preduslovi, Osnovni scenario, Postuslovi, Alternativna scenarija, Specijalni zahtevi, Tehnološki zahtevi, Otvorena pitanja.",
      "Dopustivi ulaz u softverski sistem je definisan potpisom (signaturom), koji sadrži naziv sistemske operacije koja se poziva i skupom ulaznih argumenata.",
      "Ugovori se prave za sistemske operacije i oni opisuju njeno ponašanje. Ugovori opisuju šta operacija treba da radi, bez objašnjenja kako će to da radi. Jedan ugovor je vezan za jednu sistemsku operaciju. Sekcije: Operacija, Veza sa SK, Preduslov (stanje pre izvršenja), Postuslov (stanje posle izvršenja). Preduslovi ukazuju šta je trebalo da se desi da bi se SO izvršila. Postuslovi ukazuju šta treba da se desi nakon izvršenja SO."
    ],
    "correctAnswer": "Ugovori se prave za sistemske operacije i oni opisuju njeno ponašanje. Ugovori opisuju šta operacija treba da radi, bez objašnjenja kako će to da radi. Jedan ugovor je vezan za jednu sistemsku operaciju. Sekcije: Operacija, Veza sa SK, Preduslov (stanje pre izvršenja), Postuslov (stanje posle izvršenja). Preduslovi ukazuju šta je trebalo da se desi da bi se SO izvršila. Postuslovi ukazuju šta treba da se desi nakon izvršenja SO."
  },
  {
    "id": 20,
    "question": "Šta su strukturna ograničenja, kako se proveravaju vrednosna i strukturna ograničenja?",
    "answers": [
      "Vrednosna ograničenja se odnose na dozvoljene vrednosti atributa (prosta i složena). Strukturna ograničenja su definisana kardinalnostima preslikavanja. Kod UBACI i PROMENI proveravaju se i vrednosna i strukturna (u preduslovima). Kod OBRIŠI proveravaju se strukturna (u preduslovima). Kod PRETRAŽI/PRIKAŽI se ne proveravaju.",
      "Mora se znati pravila za INSERT, UPDATE i DELETE (npr. Restrict, Cascade) za definisani relacioni model.",
      "Stanje u kome je sve u skladu sa strukturnim ograničenjima.",
      "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih."
    ],
    "correctAnswer": "Vrednosna ograničenja se odnose na dozvoljene vrednosti atributa (prosta i složena). Strukturna ograničenja su definisana kardinalnostima preslikavanja. Kod UBACI i PROMENI proveravaju se i vrednosna i strukturna (u preduslovima). Kod OBRIŠI proveravaju se strukturna (u preduslovima). Kod PRETRAŽI/PRIKAŽI se ne proveravaju."
  },
  {
    "id": 21,
    "question": "Šta je konceptualni model?",
    "answers": [
      "Na osnovu konceptualnog modela pravi se relacioni model (baza podataka). Primer: Klasa Racun postaje tabela Racun, Klasa StavkaRacuna postaje tabela StavkaRacuna sa stranim ključem ka Racunu.",
      "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih.",
      "Sistemski dijagram sekvenci prikazuje, za izdvojeni scenario SK, događaje u određenom redosledu, koji uspostavljaju interakciju između aktora i softverskog sistema.",
      "Zato što se na osnovu njega kasnije projektuje relaciona baza podataka. Baza je temelj; ako nije dobro projektovana, kasnije promene su skupe."
    ],
    "correctAnswer": "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih."
  },
  {
    "id": 22,
    "question": "Šta je asocijacija kod konceptualnih klasa?",
    "answers": [
      "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih.",
      "Od skupa slučajeva korišćenja (SK), aktora (AK) и veza između slučajeva korišćenja i aktora.",
      "Aktor izvodi: APUSO (Aktor Priprema Ulaz za Sistemsku Operaciju), APSO (Aktor Poziva Sistemsku Operaciju), ANSO (Aktor izvršava NeSistemsku Operaciju).",
      "Asocijacija je veza između konceptualnih klasa. Svaki kraj asocijacije predstavlja ulogu (ime, preslikavanje, navigaciju)."
    ],
    "correctAnswer": "Asocijacija je veza između konceptualnih klasa. Svaki kraj asocijacije predstavlja ulogu (ime, preslikavanje, navigaciju)."
  },
  {
    "id": 23,
    "question": "Transformacija konceptualnog u relacioni model",
    "answers": [
      "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih.",
      "Zato što se na osnovu njega kasnije projektuje relaciona baza podataka. Baza je temelj; ako nije dobro projektovana, kasnije promene su skupe.",
      "Na osnovu datog konceptualnog modela (klase i veze) treba napisati relacioni model (tabele, primarne ključeve, spoljne ključeve), pazeći na prenošenje ključeva kod nasleđivanja i jakih/slabih objekata.",
      "Na osnovu konceptualnog modela pravi se relacioni model (baza podataka). Primer: Klasa Racun postaje tabela Racun, Klasa StavkaRacuna postaje tabela StavkaRacuna sa stranim ključem ka Racunu."
    ],
    "correctAnswer": "Na osnovu konceptualnog modela pravi se relacioni model (baza podataka). Primer: Klasa Racun postaje tabela Racun, Klasa StavkaRacuna postaje tabela StavkaRacuna sa stranim ključem ka Racunu."
  },
  {
    "id": 24,
    "question": "Troniovojska arhitektura",
    "answers": [
      "Aplikaciona logika opisuje strukturu i ponašanje sistema. Sastoji se od kontrolera aplikacione logike, poslovne logike (domenske klase i sistemske operacije) i brokera baze podataka.",
      "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike. Sastoje se iz tri dela: dela za komunikaciju sa klijentom, dela za komunikaciju sa bazom i dela koji sadrži poslovnu logiku.",
      "To je makroarhitekturni patern koji deli softverski sistem na tri dela: Model (podaci/stanje), View (prikaz/ekranska forma) i Controller (upravljač koji prima zahteve i povezuje Model i View).",
      "Sastoji se od: 1. Korisničkog interfejsa (ulazno-izlazna reprezentacija sistema), 2. Aplikacione logike (struktura i ponašanje sistema), 3. Skladišta podataka (cuva stanje atributa sistema). Pravila: AL se projektuje nezavisno od KI i obrnuto; AL može imati razlicite KI; AL ne zna gde se nalazi KI."
    ],
    "correctAnswer": "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza). Pravila: AL nezavisna od KI; AL može imati više KI; Model ne zna za View."
  },
  {
    "id": 25,
    "question": "Objasniti aplikacionu logiku",
    "answers": [
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza). Pravila: AL nezavisna od KI; AL može imati više KI; Model ne zna za View.",
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz.",
      "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike.",
      "Aplikaciona logika opisuje strukturu i ponašanje sistema. Sastoji se od kontrolera aplikacione logike, poslovne logike (domenske klase i sistemske operacije) i brokera baze podataka."
    ],
    "correctAnswer": "Aplikaciona logika opisuje strukturu i ponašanje sistema. Sastoji se od kontrolera aplikacione logike, poslovne logike (domenske klase i sistemske operacije) i brokera baze podataka."
  },
  {
    "id": 26,
    "question": "Ekranske forme kod korisničkog interfejsa",
    "answers": [
      "Korisnički interfejs predstavlja realizaciju ulaza i/ili izlaza softverskog sistema. (Definicija LAZ1). NIJE deo softverskog sistema.",
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz.",
      "Grafički korisnički interfejs (forme) generiše događaje (npr. klik na dugme). Kontroler korisničkog interfejsa prima te događaje, obrađuje ih i putem soketa šalje zahteve serveru.",
      "Ekranska forma je odgovorna da prihvata podatke i događaje od aktora, poziva kontrolera UI i prikazuje podatke. Dva aspekta: Projektovanje scenarija SK (kako se koristi forma) i projektovanje metoda forme."
    ],
    "correctAnswer": "Ekranska forma je odgovorna da prihvata podatke i događaje od aktora, poziva kontrolera UI i prikazuje podatke. Dva aspekta: Projektovanje scenarija SK (kako se koristi forma) i projektovanje metoda forme."
  },
  {
    "id": 27,
    "question": "Šta je korisnički interfejs?",
    "answers": [
      "Ekranska forma je odgovorna da prihvata podatke i događaje od aktora, poziva kontrolera UI i prikazuje podatke. Dva aspekta: Projektovanje scenarija SK (kako se koristi forma) i projektovanje metoda forme.",
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza).",
      "Grafički korisnički interfejs (forme) generiše događaje (npr. klik na dugme). Kontroler korisničkog interfejsa prima te događaje, obrađuje ih i putem soketa šalje zahteve serveru.",
      "Korisnički interfejs predstavlja realizaciju ulaza i/ili izlaza softverskog sistema. (Definicija LAZ1). NIJE deo softverskog sistema."
    ],
    "correctAnswer": "Korisnički interfejs predstavlja realizaciju ulaza i/ili izlaza softverskog sistema. (Definicija LAZ1). NIJE deo softverskog sistema."
  },
  {
    "id": 28,
    "question": "Objasniti šta je kontroler korisničkog interfejsa i kontroler aplikacione logike",
    "answers": [
      "Kontroler AL podiže ServerSocket(port). U petlji čeka klijente (ss.accept()). Kada se klijent poveže, kreira novu nit (Klijent) i prosleđuje joj soket.",
      "Aplikaciona logika opisuje strukturu i ponašanje sistema. Sastoji se od kontrolera aplikacione logike, poslovne logike (domenske klase i sistemske operacije) i brokera baze podataka.",
      "Grafički korisnički interfejs (forme) generiše događaje (npr. klik na dugme). Kontroler korisničkog interfejsa prima te događaje, obrađuje ih i putem soketa šalje zahteve serveru.",
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz. Kontroler AL: podiže serverski soket, osluškuje mrežu, za svakog klijenta kreira nit (NitKlijenta) koja uspostavlja vezu."
    ],
    "correctAnswer": "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz. Kontroler AL: podiže serverski soket, osluškuje mrežu, za svakog klijenta kreira nit (NitKlijenta) koja uspostavlja vezu."
  },
  {
    "id": 29,
    "question": "Template method pattern",
    "answers": [
      "Obezbeđuje klasi samo jedno pojavljivanje (instancu) i globalni pristup do nje.",
      "Obezbeđuje interfejs za kreiranje familije povezanih ili zavisnih objekata bez navođenja (specifikovanja) njihovih konkretnih klasa.",
      "Definiše jedan-više zavisnost između objekata, tako da promena stanja nekog objekta utiče automatski na promenu stanja svih drugih objekata koji su povezani sa njim.",
      "Definiše kostur (skelet) algoritma u operaciji, prepuštajući definisanje nekih koraka potklasama. Template Method omogućava potklasama da redefinišu određene korake algoritma bez promene strukture algoritma."
    ],
    "correctAnswer": "Definiše kostur (skelet) algoritma u operaciji, prepuštajući definisanje nekih koraka potklasama. Template Method omogućava potklasama da redefinišu određene korake algoritma bez promene strukture algoritma."
  },
  {
    "id": 30,
    "question": "Open-closed princip",
    "answers": [
      "1. Moduli višeg nivoa ne treba da zavise od modula nižeg nivoa. Oba treba da zavise od apstrakcije. 2. Apstrakcije ne treba da zavise od detalja. Detalji treba da zavise od apstrakcije.",
      "Kohezija: mera povezanosti metoda unutar klase (želimo VISOKU koheziju - metode rade zajedno na jednom zadatku). Spojenost (Coupling): mera zavisnosti između klasa (želimo SLABU spojenost - klase su nezavisne).",
      "Apstrakcija i Spojenost (Coupling) i Kohezija.",
      "Modul treba da bude otvoren za proširenje, ali zatvoren za modifikaciju. (Open for extension, closed for modification)."
    ],
    "correctAnswer": "Modul treba da bude otvoren za proširenje, ali zatvoren za modifikaciju. (Open for extension, closed for modification)."
  },
  {
    "id": 31,
    "question": "Spojenost i kohezija",
    "answers": [
      "Modul treba da bude otvoren za proširenje, ali zatvoren za modifikaciju. (Open for extension, closed for modification).",
      "1. Moduli višeg nivoa ne treba da zavise od modula nižeg nivoa. Oba treba da zavise od apstrakcije. 2. Apstrakcije ne treba da zavise od detalja. Detalji treba da zavise od apstrakcije.",
      "Nezavisnost scenarija povećava redundansu ali olakšava održavanje. Redundansa i lakoća održavanja su često obrnuto srazmerni u ovom kontekstu.",
      "Kohezija: mera povezanosti metoda unutar klase (želimo VISOKU koheziju - metode rade zajedno na jednom zadatku). Spojenost (Coupling): mera zavisnosti između klasa (želimo SLABU spojenost - klase su nezavisne)."
    ],
    "correctAnswer": "Kohezija: mera povezanosti metoda unutar klase (želimo VISOKU koheziju - metode rade zajedno na jednom zadatku). Spojenost (Coupling): mera zavisnosti između klasa (želimo SLABU spojenost - klase su nezavisne)."
  },
  {
    "id": 32,
    "question": "Šta je rezultat faze projektovanja?",
    "answers": [
      "Faza analize opisuje logičku strukturu i ponašanje softverskog sistema (poslovnu logiku). Rezultat su: dijagram klasa (konceptualni model), relacioni model, dijagrami sekvenci i ugovori sistemskih operacija.",
      "Razvoj (životni ciklus) softverskog sistema se sastoji iz sledećih faza (Slika RASS): Prikupljanja zahteva od korisnika, Analize, Projektovanja, Implementacije, Testiranja.",
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza).",
      "Arhitektura softverskog sistema (tronivojska), definisane komponente, interfejsi, ekranske forme, detaljno projektovanje klasa i baze podataka."
    ],
    "correctAnswer": "Arhitektura softverskog sistema (tronivojska), definisane komponente, interfejsi, ekranske forme, detaljno projektovanje klasa i baze podataka."
  },
  {
    "id": 33,
    "question": "Koliko niti se izvršava na serverskoj strani? Obrazloži",
    "answers": [
      "Glavna: while(true){ socket.accept(); new Thread(client).start(); } Pomoćna (run metoda): while(uslov) { ...radi... }",
      "Kontroler AL podiže ServerSocket(port). U petlji čeka klijente (ss.accept()). Kada se klijent poveže, kreira novu nit (Klijent) i prosleđuje joj soket.",
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz.",
      "Izvršava se 1 (glavna nit koja osluškuje port) + N (niti klijenata), gde je N broj aktivnih klijentskih konekcija. Svaki klijent dobija svoju nit za komunikaciju."
    ],
    "correctAnswer": "Izvršava se 1 (glavna nit koja osluškuje port) + N (niti klijenata), gde je N broj aktivnih klijentskih konekcija. Svaki klijent dobija svoju nit za komunikaciju."
  },
  {
    "id": 34,
    "question": "Holivudski princip",
    "answers": [
      "1. Moduli višeg nivoa ne treba da zavise od modula nižeg nivoa. Oba treba da zavise od apstrakcije. 2. Apstrakcije ne treba da zavise od detalja. Detalji treba da zavise od apstrakcije.",
      "Modul treba da bude otvoren za proširenje, ali zatvoren za modifikaciju. (Open for extension, closed for modification).",
      "Kohezija: mera povezanosti metoda unutar klase (želimo VISOKU koheziju - metode rade zajedno na jednom zadatku). Spojenost (Coupling): mera zavisnosti između klasa (želimo SLABU spojenost - klase su nezavisne).",
      "\"Don't call us, we'll call you.\" Komponente višeg nivoa ne zavise od komponenti nižeg nivoa. Niži nivo se poziva samo kad je potrebno (inverzija kontrole). Primer: Broker baze podataka."
    ],
    "correctAnswer": "\"Don't call us, we'll call you.\" Komponente višeg nivoa ne zavise od komponenti nižeg nivoa. Niži nivo se poziva samo kad je potrebno (inverzija kontrole). Primer: Broker baze podataka."
  },
  {
    "id": 35,
    "question": "Napisati kod genericke metode izmeniSlog (promeniSlog)",
    "answers": [
      "Glavna: while(true){ socket.accept(); new Thread(client).start(); } Pomoćna (run metoda): while(uslov) { ...radi... }",
      "Kontroler AL podiže ServerSocket(port). U petlji čeka klijente (ss.accept()). Kada se klijent poveže, kreira novu nit (Klijent) i prosleđuje joj soket.",
      "public boolean obrisiSlog(OpstiDomenskiObjekat odo) { String upit = \"DELETE FROM \" + odo.vratiImeKlase() + \" WHERE \" + odo.vratiUslovZaNadjiSlog(); st.executeUpdate(upit); ... }",
      "public boolean promeniSlog(OpstiDomenskiObjekat odo) { String upit = \"UPDATE \" + odo.vratiImeKlase() + \" SET \" + odo.postaviVrednostiAtributa() + \" WHERE \" + odo.vratiUslovZaNadjiSlog(); st.executeUpdate(upit); ... }"
    ],
    "correctAnswer": "public boolean promeniSlog(OpstiDomenskiObjekat odo) { String upit = \"UPDATE \" + odo.vratiImeKlase() + \" SET \" + odo.postaviVrednostiAtributa() + \" WHERE \" + odo.vratiUslovZaNadjiSlog(); st.executeUpdate(upit); ... }"
  },
  {
    "id": 36,
    "question": "Da li u jednom izvrsenju SK mogu da se izvrse 2 scenarija?",
    "answers": [
      "Da, npr. kod logovanja ukoliko šifra nije dobra, prikazuje se greška i ponovo se unosi šifra.",
      "Da.",
      "Ne, zahtev za izvršenje SO se ne odigrava kontinualno nego diskretno. Korisnik interaktivno poziva jednu po jednu sistemsku operaciju u diskretnim vremenskim intervalima.",
      "Ne mogu, jer svaki slučaj korišćenja se sastoji iz glavnog i alternativnog scenarija koji se međusobno isključuju."
    ],
    "correctAnswer": "Ne mogu, jer svaki slučaj korišćenja se sastoji iz glavnog i alternativnog scenarija koji se međusobno isključuju."
  },
  {
    "id": 37,
    "question": "Zašto je uveden kontrolor APL?",
    "answers": [
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz.",
      "Služi kao posrednik između baze i softverskog sistema. Zadužen је za sve operacije nad bazom (select, insert, update, delete).",
      "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike.",
      "Da bi se sve odvijalo preko jednostavnog interfejsa. On krije poslovnu logiku sistema i pruža korisniku što jednostavnije korišćenje sistema. Takođe upravlja mrežnom komunikacijom (soketi)."
    ],
    "correctAnswer": "Da bi se sve odvijalo preko jednostavnog interfejsa. On krije poslovnu logiku sistema i pruža korisniku što jednostavnije korišćenje sistema. Takođe upravlja mrežnom komunikacijom (soketi)."
  },
  {
    "id": 38,
    "question": "Zašto je potrebno da se def. relacioni model u fazi analize?",
    "answers": [
      "Na osnovu konceptualnog modela pravi se relacioni model (baza podataka). Primer: Klasa Racun postaje tabela Racun.",
      "Na osnovu datog konceptualnog modela (klase i veze) treba napisati relacioni model (tabele, primarne ključeve, spoljne ključeve), pazeći na prenošenje ključeva kod nasleđivanja i jakih/slabih objekata.",
      "Mora se znati pravila za INSERT, UPDATE i DELETE (npr. Restrict, Cascade) za definisani relacioni model.",
      "Zato što se na osnovu njega kasnije projektuje relaciona baza podataka. Baza je temelj; ako nije dobro projektovana, kasnije promene su skupe."
    ],
    "correctAnswer": "Zato što se na osnovu njega kasnije projektuje relaciona baza podataka. Baza je temelj; ako nije dobro projektovana, kasnije promene su skupe."
  },
  {
    "id": 39,
    "question": "Da li iste akcije mogu da se koriste u više scenarija istog SK?",
    "answers": [
      "Ne mogu, jer svaki slučaj korišćenja se sastoji iz glavnog i alternativnog scenarija koji se međusobno isključuju.",
      "Ne, zahtev za izvršenje SO se ne odigrava kontinualno nego diskretno. Korisnik interaktivno poziva jednu po jednu sistemsku operaciju u diskretnim vremenskim intervalima.",
      "Da, npr. kod logovanja ukoliko šifra nije dobra, prikazuje se greška i ponovo se unosi šifra.",
      "Da."
    ],
    "correctAnswer": "Da."
  },
  {
    "id": 40,
    "question": "Da li u jednom SK moze da se ponovi ista akcija?",
    "answers": [
      "Ne mogu, jer svaki slučaj korišćenja se sastoji iz glavnog i alternativnog scenarija koji se međusobno isključuju.",
      "Ne, zahtev za izvršenje SO se ne odigrava kontinualno nego diskretno. Korisnik interaktivno poziva jednu po jednu sistemsku operaciju u diskretnim vremenskim intervalima.",
      "Da.",
      "Da, npr. kod logovanja ukoliko šifra nije dobra, prikazuje se greška i ponovo se unosi šifra."
    ],
    "correctAnswer": "Da, npr. kod logovanja ukoliko šifra nije dobra, prikazuje se greška i ponovo se unosi šifra."
  },
  {
    "id": 41,
    "question": "Šta se dešava sa SO kad preduslovi nisu zadovoljeni?",
    "answers": [
      "Ugovori opisuju šta operacija treba da radi. Sekcije: Operacija, Veza sa SK, Preduslov (stanje pre izvršenja), Postuslov (stanje posle izvršenja).",
      "Ne bi se tačno znalo šta SO treba da radi, koje su veze sa drugim SK, i najvažnije, ne bi se znali postuslovi (šta je rezultat SO).",
      "Vrednosna ograničenja se odnose na dozvoljene vrednosti atributa (prosta i složena).",
      "Sistemska operacija se neće izvršiti. Preduslovi garantuju da je sistem u odgovarajućem stanju za izvršenje operacije."
    ],
    "correctAnswer": "Sistemska operacija se neće izvršiti. Preduslovi garantuju da je sistem u odgovarajućem stanju za izvršenje operacije."
  },
  {
    "id": 42,
    "question": "Da li je KI deo softverskog sistema?",
    "answers": [
      "Softverski sistem je sistem međusobno povezanih komponenti zasnovanih na softveru koji čini deo računarskog sistema.",
      "Korisnički interfejs predstavlja realizaciju ulaza i/ili izlaza softverskog sistema.",
      "Radi fleksibilnosti (različiti interfejsi za istu logiku) i lakšeg održavanja (promena UI ne utiče na logiku).",
      "Ne. KI nije deo softverskog sistema; sistem nema predstavu gde se KI nalazi (Model-View Separation)."
    ],
    "correctAnswer": "Ne. KI nije deo softverskog sistema; sistem nema predstavu gde se KI nalazi (Model-View Separation)."
  },
  {
    "id": 43,
    "question": "Od čega se sastoji Model SK?",
    "answers": [
      "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora.",
      "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih.",
      "Faza analize opisuje logičku strukturu i ponašanje softverskog sistema (poslovnu logiku).",
      "Od skupa slučajeva korišćenja (SK), aktora (AK) и veza između slučajeva korišćenja i aktora."
    ],
    "correctAnswer": "Od skupa slučajeva korišćenja (SK), aktora (AK) и veza između slučajeva korišćenja i aktora."
  },
  {
    "id": 44,
    "question": "Da li klase SO pozivaju jedna drugu?",
    "answers": [
      "Radi lakšeg održavanja, modularnosti i izbegavanja dupliranja koda (ako se koristi nasleđivanje/Template method).",
      "Aktor izvodi: APUSO (Aktor Priprema Ulaz za Sistemsku Operaciju), APSO (Aktor Poziva Sistemsku Operaciju), ANSO (Aktor izvršava NeSistemsku Operaciju).",
      "Radi fleksibilnosti (različiti interfejsi za istu logiku) i lakšeg održavanja (promena UI ne utiče na logiku).",
      "Ne. Sistemske operacije su nezavisne (obično)."
    ],
    "correctAnswer": "Ne. Sistemske operacije su nezavisne (obično)."
  },
  {
    "id": 45,
    "question": "Zašto je svaka SO implementirana u posebnoj klasi?",
    "answers": [
      "Ne. Sistemske operacije su nezavisne (obično).",
      "Radi fleksibilnosti (različiti interfejsi za istu logiku) i lakšeg održavanja (promena UI ne utiče na logiku).",
      "Nezavisnost scenarija povećava redundansu ali olakšava održavanje. Redundansa i lakoća održavanja su često obrnuto srazmerni u ovom kontekstu.",
      "Radi lakšeg održavanja, modularnosti i izbegavanja dupliranja koda (ako se koristi nasleđivanje/Template method)."
    ],
    "correctAnswer": "Radi lakšeg održavanja, modularnosti i izbegavanja dupliranja koda (ako se koristi nasleđivanje/Template method)."
  },
  {
    "id": 46,
    "question": "Čemu služi DBBR (Broker Baze Podataka)?",
    "answers": [
      "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike.",
      "Znatno teže bi bilo održavanje sistema jer bi SQL kod bio izmešan sa poslovnom logikom. Imali bismo više posla da dodamo novu funkcionalnost.",
      "Generički i Perzistentni okvir.",
      "Služi kao posrednik između baze i softverskog sistema. Zadužen је za sve operacije nad bazom (select, insert, update, delete)."
    ],
    "correctAnswer": "Služi kao posrednik između baze i softverskog sistema. Zadužen је za sve operacije nad bazom (select, insert, update, delete)."
  },
  {
    "id": 47,
    "question": "Zašto se AL projektuje nezavisno od KI?",
    "answers": [
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza).",
      "Ne. KI nije deo softverskog sistema; sistem nema predstavu gde se KI nalazi (Model-View Separation).",
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz.",
      "Radi fleksibilnosti (različiti interfejsi za istu logiku) i lakšeg održavanja (promena UI ne utiče na logiku)."
    ],
    "correctAnswer": "Radi fleksibilnosti (različiti interfejsi za istu logiku) i lakšeg održavanja (promena UI ne utiče na logiku)."
  },
  {
    "id": 48,
    "question": "U kakvoj su vezi redundansa i održavanje sistema?",
    "answers": [
      "Kohezija: mera povezanosti metoda unutar klase (želimo VISOKU koheziju - metode rade zajedno na jednom zadatku). Spojenost (Coupling): mera zavisnosti između klasa (želimo SLABU spojenost - klase su nezavisne).",
      "Radi lakšeg održavanja, modularnosti i izbegavanja dupliranja koda (ako se koristi nasleđivanje/Template method).",
      "Radi fleksibilnosti (različiti interfejsi za istu logiku) i lakšeg održavanja (promena UI ne utiče na logiku).",
      "Nezavisnost scenarija povećava redundansu ali olakšava održavanje. Redundansa i lakoća održavanja su često obrnuto srazmerni u ovom kontekstu (veća redundansa, lakše lokalno održavanje, teže globalne izmene? - Ili obrnuto: ako su scenarija spregnuta, održavanje je teže)."
    ],
    "correctAnswer": "Nezavisnost scenarija povećava redundansu ali olakšava održavanje. Redundansa i lakoća održavanja su često obrnuto srazmerni u ovom kontekstu (veća redundansa, lakše lokalno održavanje, teže globalne izmene? - Ili obrnuto: ako su scenarija spregnuta, održavanje je teže)."
  },
  {
    "id": 49,
    "question": "Princip inverzije zavisnosti (Dependency Inversion)",
    "answers": [
      "Modul treba da bude otvoren za proširenje, ali zatvoren za modifikaciju. (Open for extension, closed for modification).",
      "Open-Closed Principle, Liskov Substitution Principle, Dependency Inversion Principle, Dependency Injection Principle.",
      "Kohezija: mera povezanosti metoda unutar klase (želimo VISOKU koheziju - metode rade zajedno na jednom zadatku). Spojenost (Coupling): mera zavisnosti između klasa (želimo SLABU spojenost - klase su nezavisne).",
      "1. Moduli višeg nivoa ne treba da zavise od modula nižeg nivoa. Oba treba da zavise od apstrakcije. 2. Apstrakcije ne treba da zavise od detalja. Detalji treba da zavise od apstrakcije."
    ],
    "correctAnswer": "1. Moduli višeg nivoa ne treba da zavise od modula nižeg nivoa. Oba treba da zavise od apstrakcije. 2. Apstrakcije ne treba da zavise od detalja. Detalji treba da zavise od apstrakcije."
  },
  {
    "id": 50,
    "question": "Iskodirati glavnu i pomoćnu nit",
    "answers": [
      "Kontroler AL podiže ServerSocket(port). U petlji čeka klijente (ss.accept()). Kada se klijent poveže, kreira novu nit (Klijent) i prosleđuje joj soket. Nit (run metoda) čita zahteve (readObject), poziva odgovarajuće SO (npr. KreirajNovi.kreirajNovi) i vraća odgovor (writeObject).",
      "public boolean promeniSlog(OpstiDomenskiObjekat odo) { String upit = \"UPDATE \" + odo.vratiImeKlase() + \" SET \" + odo.postaviVrednostiAtributa() + \" WHERE \" + odo.vratiUslovZaNadjiSlog(); st.executeUpdate(upit); ... }",
      "Glavna: while(false){ socket.close(); } Pomoćna (run metoda): while(true) { ...sleep... }",
      "Glavna: while(true){ socket.accept(); new Thread(client).start(); } Pomoćna (run metoda): while(uslov) { ...radi... }"
    ],
    "correctAnswer": "Glavna: while(true){ socket.accept(); new Thread(client).start(); } Pomoćna (run metoda): while(uslov) { ...radi... }"
  },
  {
    "id": 51,
    "question": "Šta su aplikacioni serveri?",
    "answers": [
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza).",
      "Služi kao posrednik između baze i softverskog sistema. Zadužen је za sve operacije nad bazom (select, insert, update, delete).",
      "Aplikaciona logika opisuje strukturu i ponašanje sistema. Sastoji se od kontrolera aplikacione logike, poslovne logike (domenske klase i sistemske operacije) i brokera baze podataka.",
      "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike. Sastoje se iz tri dela: dela za komunikaciju sa klijentom, dela za komunikaciju sa bazom i dela koji sadrži poslovnu logiku."
    ],
    "correctAnswer": "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike. Sastoje se iz tri dela: dela za komunikaciju sa klijentom, dela za komunikaciju sa bazom i dela koji sadrži poslovnu logiku."
  },
  {
    "id": 52,
    "question": "Kako se šalje objekat domenske klase od klijenta do servera?",
    "answers": [
      "Serijalizacija je proces konvertovanja objekta u niz bajtova kako bi se mogao sačuvati u fajl ili poslati preko mreže. Deserijalizacija je obrnut proces.",
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz.",
      "Kontroler AL podiže ServerSocket(port). U petlji čeka klijente (ss.accept()). Kada se klijent poveže, kreira novu nit (Klijent) i prosleđuje joj soket.",
      "Šalje se preko soketa korišćenjem objektih tokova (ObjectOutputStream). Klasa objekta mora biti serijalizabilna (implementirati Serializable interfejs). Klijent konvertuje objekat u niz bajtova (serijalizacija) i šalje ga mrežom, a server ga prima i rekonstruiše (deserijalizacija)."
    ],
    "correctAnswer": "Šalje se preko soketa korišćenjem objektih tokova (ObjectOutputStream). Klasa objekta mora biti serijalizabilna (implementirati Serializable interfejs). Klijent konvertuje objekat u niz bajtova (serijalizacija) i šalje ga mrežom, a server ga prima i rekonstruiše (deserijalizacija)."
  },
  {
    "id": 53,
    "question": "Šta je serijalizacija?",
    "answers": [
      "Šalje se preko soketa korišćenjem objektih tokova (ObjectOutputStream). Klasa objekta mora biti serijalizabilna (implementirati Serializable interfejs).",
      "Na osnovu konceptualnog modela pravi se relacioni model (baza podataka).",
      "Na osnovu datog konceptualnog modela (klase i veze) treba napisati relacioni model (tabele, primarne ključeve, spoljne ključeve).",
      "Serijalizacija je proces konvertovanja objekta u niz bajtova kako bi se mogao sačuvati u fajl ili poslati preko mreže. Deserijalizacija je obrnut proces."
    ],
    "correctAnswer": "Serijalizacija je proces konvertovanja objekta u niz bajtova kako bi se mogao sačuvati u fajl ili poslati preko mreže. Deserijalizacija je obrnut proces."
  },
  {
    "id": 54,
    "question": "Primer za generisanje i prijem događaja",
    "answers": [
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz.",
      "Ekranska forma je odgovorna da prihvata podatke i događaje od aktora, poziva kontrolera UI i prikazuje podatke. Dva aspekta: Projektovanje scenarija SK (kako se koristi forma) i projektovanje metoda forme.",
      "Aktor izvodi: APUSO (Aktor Priprema Ulaz za Sistemsku Operaciju), APSO (Aktor Poziva Sistemsku Operaciju), ANSO (Aktor izvršava NeSistemsku Operaciju).",
      "Grafički korisnički interfejs (forme) generiše događaje (npr. klik na dugme). Kontroler korisničkog interfejsa prima te događaje, obrađuje ih i putem soketa šalje zahteve serveru."
    ],
    "correctAnswer": "Grafički korisnički interfejs (forme) generiše događaje (npr. klik na dugme). Kontroler korisničkog interfejsa prima te događaje, obrađuje ih i putem soketa šalje zahteve serveru."
  },
  {
    "id": 55,
    "question": "Dati primer realizacije neke SO koja je predstavljena preko sekvencnog dijagrama",
    "answers": [
      "Sistemski dijagram sekvenci prikazuje, za izdvojeni scenario SK, događaje u određenom redosledu, koji uspostavljaju interakciju između aktora i softverskog sistema.",
      "Ugovori opisuju šta operacija treba da radi. Sekcije: Operacija, Veza sa SK, Preduslov (stanje pre izvršenja), Postuslov (stanje posle izvršenja).",
      "Dobijaju se sistemske operacije koje treba projektovati (i njihovi potpisi).",
      "InsertSistemskaOperacija: 1. insert -> ubaciSlog(Artikal), 2. -> DBBroker (poziv brokera), 3. <-- signal (povratna informacija o uspešnosti)."
    ],
    "correctAnswer": "InsertSistemskaOperacija: 1. insert -> ubaciSlog(Artikal), 2. -> DBBroker (poziv brokera), 3. <-- signal (povratna informacija o uspešnosti)."
  },
  {
    "id": 56,
    "question": "Šta se dobija na osnovu sekvencnog dijagrama u fazi analize?",
    "answers": [
      "Faza analize opisuje logičku strukturu i ponašanje softverskog sistema (poslovnu logiku). Struktura se opisuje pomoću konceptualnog i relacionog modela.",
      "Arhitektura softverskog sistema (tronivojska), definisane komponente, interfejsi, ekranske forme, detaljno projektovanje klasa i baze podataka.",
      "InsertSistemskaOperacija: 1. insert -> ubaciSlog(Artikal), 2. -> DBBroker (poziv brokera), 3. <-- signal (povratna informacija o uspešnosti).",
      "Dobijaju se sistemske operacije koje treba projektovati (i njihovi potpisi)."
    ],
    "correctAnswer": "Dobijaju se sistemske operacije koje treba projektovati (i njihovi potpisi)."
  },
  {
    "id": 57,
    "question": "Ako se ne naprave ugovori koji bi problemi bili?",
    "answers": [
      "Sistemska operacija se neće izvršiti. Preduslovi garantuju da je sistem u odgovarajućem stanju za izvršenje operacije.",
      "Znatno teže bi bilo održavanje sistema jer bi SQL kod bio izmešan sa poslovnom logikom. Imali bismo više posla da dodamo novu funkcionalnost.",
      "Mora se znati pravila za INSERT, UPDATE i DELETE (npr. Restrict, Cascade) za definisani relacioni model.",
      "Ne bi se tačno znalo šta SO treba da radi, koje su veze sa drugim SK, i najvažnije, ne bi se znali postuslovi (šta je rezultat SO), što bi dovelo do problema u projektovanju i implementaciji."
    ],
    "correctAnswer": "Ne bi se tačno znalo šta SO treba da radi, koje su veze sa drugim SK, i najvažnije, ne bi se znali postuslovi (šta je rezultat SO), što bi dovelo do problema u projektovanju i implementaciji."
  },
  {
    "id": 58,
    "question": "Da li su akcije koje izvodi aktor kontinualne?",
    "answers": [
      "Ne mogu, jer svaki slučaj korišćenja se sastoji iz glavnog i alternativnog scenarija koji se međusobno isključuju.",
      "Da, npr. kod logovanja ukoliko šifra nije dobra, prikazuje se greška i ponovo se unosi šifra.",
      "Da.",
      "Ne, zahtev za izvršenje SO se ne odigrava kontinualno nego diskretno. Korisnik interaktivno poziva jednu po jednu sistemsku operaciju u diskretnim vremenskim intervalima."
    ],
    "correctAnswer": "Ne, zahtev za izvršenje SO se ne odigrava kontinualno nego diskretno. Korisnik interaktivno poziva jednu po jednu sistemsku operaciju u diskretnim vremenskim intervalima."
  },
  {
    "id": 59,
    "question": "Dijagram prelaza stanja",
    "answers": [
      "Sistemski dijagram sekvenci prikazuje, za izdvojeni scenario SK, događaje u određenom redosledu, koji uspostavljaju interakciju između aktora i softverskog sistema.",
      "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih.",
      "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora.",
      "Koristi se za modelovanje dinamičkog ponašanja objekta. Prikazuje stanja kroz koja objekat prolazi tokom svog životnog ciklusa kao odgovor na događaje."
    ],
    "correctAnswer": "Koristi se za modelovanje dinamičkog ponašanja objekta. Prikazuje stanja kroz koja objekat prolazi tokom svog životnog ciklusa kao odgovor na događaje."
  },
  {
    "id": 60,
    "question": "Transakcije commit, rollback",
    "answers": [
      "Vrednosna ograničenja se odnose na dozvoljene vrednosti atributa (prosta i složena). Strukturna ograničenja su definisana kardinalnostima preslikavanja.",
      "Serijalizacija je proces konvertovanja objekta u niz bajtova kako bi se mogao sačuvati u fajl ili poslati preko mreže. Deserijalizacija je obrnut proces.",
      "Služi kao posrednik između baze i softverskog sistema. Zadužen је za sve operacije nad bazom (select, insert, update, delete).",
      "Commit potvrđuje da su sve operacije u okviru transakcije uspešno izvršene i trajno čuva promene. Rollback poništava sve efekte operacija u okviru transakcije ako dođe do greške, vraćajući sistem u prethodno stanje."
    ],
    "correctAnswer": "Commit potvrđuje da su sve operacije u okviru transakcije uspešno izvršene i trajno čuva promene. Rollback poništava sve efekte operacija u okviru transakcije ako dođe do greške, vraćajući sistem u prethodno stanje."
  },
  {
    "id": 61,
    "question": "Ako ne postoji DBBR (Broker Baze), koji su problemi?",
    "answers": [
      "Ne bi se tačno znalo šta SO treba da radi, koje su veze sa drugim SK, i najvažnije, ne bi se znali postuslovi (šta je rezultat SO), što bi dovelo do problema u projektovanju i implementaciji.",
      "Mora se znati pravila za INSERT, UPDATE i DELETE (npr. Restrict, Cascade) za definisani relacioni model.",
      "Služi kao posrednik između baze i softverskog sistema. Zadužen је za sve operacije nad bazom (select, insert, update, delete).",
      "Znatno teže bi bilo održavanje sistema jer bi SQL kod bio izmešan sa poslovnom logikom. Imali bismo više posla da dodamo novu funkcionalnost i teže bi se upravljalo materijalizacijom i dematerijalizacijom objekata."
    ],
    "correctAnswer": "Znatno teže bi bilo održavanje sistema jer bi SQL kod bio izmešan sa poslovnom logikom. Imali bismo više posla da dodamo novu funkcionalnost i teže bi se upravljalo materijalizacijom i dematerijalizacijom objekata."
  },
  {
    "id": 62,
    "question": "Može li sistem imati više scenarija?",
    "answers": [
      "Ne mogu, jer svaki slučaj korišćenja se sastoji iz glavnog i alternativnog scenarija koji se međusobno isključuju.",
      "Da, npr. kod logovanja ukoliko šifra nije dobra, prikazuje se greška i ponovo se unosi šifra.",
      "Slučaj korišćenja opisuje skup scenarija (use-case pojavljivanja), odnosno skup željenih korišćenja sistema od strane aktora.",
      "Da, sistem se sastoji od skupa Slučajeva Korišćenja, a svaki SK ima jedan glavni i više alternativnih scenarija."
    ],
    "correctAnswer": "Da, sistem se sastoji od skupa Slučajeva Korišćenja, a svaki SK ima jedan glavni i više alternativnih scenarija."
  },
  {
    "id": 63,
    "question": "Šta je generička metoda?",
    "answers": [
      "Definiše interfejs za kreiranje objekata, ali omogućava podklasama da donesu odluku koju klasu će instancirati (prenosi nadležnost instanciranja na podklase).",
      "Definiše kostur (skelet) algoritma u operaciji, prepuštajući definisanje nekih koraka potklasama. Template Method omogućava potklasama da redefinišu određene korake algoritma bez promene strukture algoritma.",
      "Služi kao posrednik između baze i softverskog sistema. Zadužen је za sve operacije nad bazom (select, insert, update, delete).",
      "Metoda projektovana da radi sa opštim tipom (interfejsom ili apstraktnom klasom, npr. OpstiDomenskiObjekat) umesto sa konkretnim tipom, čime se omogućava njena primena na različite klase bez dupliranja koda."
    ],
    "correctAnswer": "Metoda projektovana da radi sa opštim tipom (interfejsom ili apstraktnom klasom, npr. OpstiDomenskiObjekat) umesto sa konkretnim tipom, čime se omogućava njena primena na različite klase bez dupliranja koda."
  },
  {
    "id": 64,
    "question": "Objasniti preko koda kontroler aplikacione logike",
    "answers": [
      "Glavna: while(true){ socket.accept(); new Thread(client).start(); } Pomoćna (run metoda): while(uslov) { ...radi... }",
      "public boolean promeniSlog(OpstiDomenskiObjekat odo) { String upit = \"UPDATE \" + odo.vratiImeKlase() + \" SET \" + odo.postaviVrednostiAtributa() + \" WHERE \" + odo.vratiUslovZaNadjiSlog(); st.executeUpdate(upit); ... }",
      "Kontroler KI: prihvata podatke od forme, konvertuje u domenski objekat, šalje zahtev aplikacionom serveru, prihvata odgovor i konvertuje za prikaz.",
      "Kontroler AL podiže ServerSocket(port). U petlji čeka klijente (ss.accept()). Kada se klijent poveže, kreira novu nit (Klijent) i prosleđuje joj soket. Nit (run metoda) čita zahteve (readObject), poziva odgovarajuće SO (npr. KreirajNovi.kreirajNovi) i vraća odgovor (writeObject)."
    ],
    "correctAnswer": "Kontroler AL podiže ServerSocket(port). U petlji čeka klijente (ss.accept()). Kada se klijent poveže, kreira novu nit (Klijent) i prosleđuje joj soket. Nit (run metoda) čita zahteve (readObject), poziva odgovarajuće SO (npr. KreirajNovi.kreirajNovi) i vraća odgovor (writeObject)."
  },
  {
    "id": 65,
    "question": "Šta podrazumeva zadatak prevođenja konceptualnog modela u relacioni model?",
    "answers": [
      "Na osnovu konceptualnog modela pravi se relacioni model (baza podataka). Primer: Klasa Racun postaje tabela Racun, Klasa StavkaRacuna postaje tabela StavkaRacuna sa stranim ključem ka Racunu.",
      "Zato što se na osnovu njega kasnije projektuje relaciona baza podataka. Baza je temelj; ako nije dobro projektovana, kasnije promene su skupe.",
      "Konceptualni model opisuje konceptualne klase domena problema. Sadrži konceptualne klase (domenske objekte) i asocijacije između njih.",
      "Na osnovu datog konceptualnog modela (klase i veze) treba napisati relacioni model (tabele, primarne ključeve, spoljne ključeve), pazeći na prenošenje ključeva kod nasleđivanja i jakih/slabih objekata."
    ],
    "correctAnswer": "Na osnovu datog konceptualnog modela (klase i veze) treba napisati relacioni model (tabele, primarne ključeve, spoljne ključeve), pazeći na prenošenje ključeva kod nasleđivanja i jakih/slabih objekata."
  },
  {
    "id": 66,
    "question": "Šta je ključno znati kod definisanja tabele strukturnih ograničenja?",
    "answers": [
      "Vrednosna ograničenja se odnose na dozvoljene vrednosti atributa (prosta i složena). Strukturna ograničenja su definisana kardinalnostima preslikavanja.",
      "Na osnovu datog konceptualnog modela (klase i veze) treba napisati relacioni model (tabele, primarne ključeve, spoljne ključeve), pazeći na prenošenje ključeva kod nasleđivanja i jakih/slabih objekata.",
      "Zato što se na osnovu njega kasnije projektuje relaciona baza podataka. Baza je temelj; ako nije dobro projektovana, kasnije promene su skupe.",
      "Mora se znati pravila za INSERT, UPDATE i DELETE (npr. Restrict, Cascade) za definisani relacioni model."
    ],
    "correctAnswer": "Mora se znati pravila za INSERT, UPDATE i DELETE (npr. Restrict, Cascade) za definisani relacioni model."
  },
  {
    "id": 67,
    "question": "Na šta treba posebno obratiti pažnju kod crtanja sistemskog dijagrama sekvenci?",
    "answers": [
      "Sistemski dijagram sekvenci prikazuje, za izdvojeni scenario SK, događaje u određenom redosledu, koji uspostavljaju interakciju između aktora i softverskog sistema.",
      "Dobijaju se sistemske operacije koje treba projektovati (i njihovi potpisi).",
      "InsertSistemskaOperacija: 1. insert -> ubaciSlog(Artikal), 2. -> DBBroker (poziv brokera), 3. <-- signal (povratna informacija o uspešnosti).",
      "Treba paziti na alternativne scenarije (grananje) na osnovu datog Slučaja Korišćenja."
    ],
    "correctAnswer": "Treba paziti na alternativne scenarije (grananje) na osnovu datog Slučaja Korišćenja."
  },
  {
    "id": 68,
    "question": "Koje dve metode razvoja softvera treba znati objasniti (uz slike)?",
    "answers": [
      "Razvoj (životni ciklus) softverskog sistema se sastoji iz sledećih faza (Slika RASS): Prikupljanja zahteva od korisnika, Analize, Projektovanja, Implementacije, Testiranja.",
      "U FURPS+ modelu znak '+' ukazuje na pomoćne zahteve koji se odnose na: Implementaciju, Interfejs, Operacije, Pakovanje, Legalnost.",
      "Open-Closed Principle, Liskov Substitution Principle, Dependency Inversion Principle, Dependency Injection Principle.",
      "SILAB metodu razvoja softvera i Uprošćenu Larmanovu metodu."
    ],
    "correctAnswer": "SILAB metodu razvoja softvera i Uprošćenu Larmanovu metodu."
  },
  {
    "id": 69,
    "question": "Šta je konzistentnost podataka (definicija iz beleški)?",
    "answers": [
      "Vrednosna ograničenja se odnose na dozvoljene vrednosti atributa (prosta i složena). Strukturna ograničenja su definisana kardinalnostima preslikavanja.",
      "Pouzdanost predstavlja sposobnost sistema da može uspešno obraditi problem (failure) koji se dešava u toku izvršenja sistema.",
      "Kohezija: mera povezanosti metoda unutar klase (želimo VISOKU koheziju - metode rade zajedno na jednom zadatku).",
      "Stanje u kome je sve u skladu sa strukturnim ograničenjima."
    ],
    "correctAnswer": "Stanje u kome je sve u skladu sa strukturnim ograničenjima."
  },
  {
    "id": 70,
    "question": "Kako glasi definicija Brokera baze podataka od dve reči (trik pitanje)?",
    "answers": [
      "Metoda projektovana da radi sa opštim tipom (interfejsom ili apstraktnom klasom, npr. OpstiDomenskiObjekat) umesto sa konkretnim tipom.",
      "Služi kao posrednik između baze i softverskog sistema. Zadužen је za sve operacije nad bazom (select, insert, update, delete).",
      "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike.",
      "Generički i Perzistentni okvir."
    ],
    "correctAnswer": "Generički i Perzistentni okvir."
  },
  {
    "id": 71,
    "question": "Koji principi projektovanja se uče (samo prva dva)?",
    "answers": [
      "Open-Closed Principle, Liskov Substitution Principle, Dependency Inversion Principle, Dependency Injection Principle.",
      "Modul treba da bude otvoren za proširenje, ali zatvoren za modifikaciju. (Open for extension, closed for modification).",
      "Kohezija: mera povezanosti metoda unutar klase (želimo VISOKU koheziju - metode rade zajedno na jednom zadatku). Spojenost (Coupling): mera zavisnosti između klasa (želimo SLABU spojenost - klase su nezavisne).",
      "Apstrakcija i Spojenost (Coupling) i Kohezija."
    ],
    "correctAnswer": "Apstrakcija i Spojenost (Coupling) i Kohezija."
  },
  {
    "id": 72,
    "question": "Koji principi OO projektovanja klasa se uče (prva 4)?",
    "answers": [
      "Apstrakcija i Spojenost (Coupling) i Kohezija.",
      "Modul treba da bude otvoren za proširenje, ali zatvoren za modifikaciju. (Open for extension, closed for modification).",
      "1. Moduli višeg nivoa ne treba da zavise od modula nižeg nivoa. Oba treba da zavise od apstrakcije. 2. Apstrakcije ne treba da zavise od detalja. Detalji treba da zavise od apstrakcije.",
      "Open-Closed Principle, Liskov Substitution Principle, Dependency Inversion Principle, Dependency Injection Principle."
    ],
    "correctAnswer": "Open-Closed Principle, Liskov Substitution Principle, Dependency Inversion Principle, Dependency Injection Principle."
  },
  {
    "id": 73,
    "question": "Šta je Singleton patern (definicija)?",
    "answers": [
      "Obezbeđuje interfejs za kreiranje familije povezanih ili zavisnih objekata bez navođenja (specifikovanja) njihovih konkretnih klasa.",
      "Definiše interfejs za kreiranje objekata, ali omogućava podklasama da donesu odluku koju klasu će instancirati (prenosi nadležnost instanciranja na podklase).",
      "Obezbeđuje jedinstven interfejs za skup interfejsa nekog podsistema, definišući interfejs visokog nivoa koji omogućava lakše korišćenje podsistema.",
      "Obezbeđuje klasi samo jedno pojavljivanje (instancu) i globalni pristup do nje."
    ],
    "correctAnswer": "Obezbeđuje klasi samo jedno pojavljivanje (instancu) i globalni pristup do nje."
  },
  {
    "id": 74,
    "question": "Šta je Abstract Factory patern (definicija)?",
    "answers": [
      "Definiše interfejs za kreiranje objekata, ali omogućava podklasama da donesu odluku koju klasu će instancirati (prenosi nadležnost instanciranja na podklase).",
      "Obezbeđuje klasi samo jedno pojavljivanje (instancu) i globalni pristup do nje.",
      "Obezbeđuje jedinstven interfejs za skup interfejsa nekog podsistema, definišući interfejs visokog nivoa koji omogućava lakše korišćenje podsistema.",
      "Obezbeđuje interfejs za kreiranje familije povezanih ili zavisnih objekata bez navođenja (specifikovanja) njihovih konkretnih klasa."
    ],
    "correctAnswer": "Obezbeđuje interfejs za kreiranje familije povezanih ili zavisnih objekata bez navođenja (specifikovanja) njihovih konkretnih klasa."
  },
  {
    "id": 75,
    "question": "Šta je MVC (Model-View-Controller) patern?",
    "answers": [
      "Sastoji se od: 1. Korisničkog interfejsa (UI), 2. Aplikacione logike (struktura i ponašanje), 3. Skladišta podataka (baza).",
      "Aplikacioni serveri su softverski okviri napravljeni na osnovu tronivojske arhitekture odgovorni da obezbede servise za realizaciju aplikacione logike.",
      "Aplikaciona logika opisuje strukturu i ponašanje sistema. Sastoji se od kontrolera aplikacione logike, poslovne logike (domenske klase i sistemske operacije) i brokera baze podataka.",
      "To je makroarhitekturni patern koji deli softverski sistem na tri dela: Model (podaci/stanje), View (prikaz/ekranska forma) i Controller (upravljač koji prima zahteve i povezuje Model i View)."
    ],
    "correctAnswer": "To je makroarhitekturni patern koji deli softverski sistem na tri dela: Model (podaci/stanje), View (prikaz/ekranska forma) i Controller (upravljač koji prima zahteve i povezuje Model i View)."
  },
  {
    "id": 76,
    "question": "Šta je Factory Method patern?",
    "answers": [
      "Obezbeđuje interfejs za kreiranje familije povezanih ili zavisnih objekata bez navođenja (specifikovanja) njihovih konkretnih klasa.",
      "Obezbeđuje klasi samo jedno pojavljivanje (instancu) i globalni pristup do nje.",
      "Konvertuje interfejs neke klase u drugi interfejs koji klijent očekuje. On prilagođava nekompatibilne interfejse.",
      "Definiše interfejs za kreiranje objekata, ali omogućava podklasama da donesu odluku koju klasu će instancirati (prenosi nadležnost instanciranja na podklase)."
    ],
    "correctAnswer": "Definiše interfejs za kreiranje objekata, ali omogućava podklasama da donesu odluku koju klasu će instancirati (prenosi nadležnost instanciranja na podklase)."
  },
  {
    "id": 77,
    "question": "Šta je Adapter patern?",
    "answers": [
      "Obezbeđuje jedinstven interfejs za skup interfejsa nekog podsistema, definišući interfejs visokog nivoa koji omogućava lakše korišćenje podsistema.",
      "Definiše jedan-više zavisnost između objekata, tako da promena stanja nekog objekta utiče automatski na promenu stanja svih drugih objekata koji su povezani sa njim.",
      "Definiše kostur (skelet) algoritma u operaciji, prepuštajući definisanje nekih koraka potklasama. Template Method omogućava potklasama da redefinišu određene korake algoritma bez promene strukture algoritma.",
      "Konvertuje interfejs neke klase u drugi interfejs koji klijent očekuje. On prilagođava nekompatibilne interfejse."
    ],
    "correctAnswer": "Konvertuje interfejs neke klase u drugi interfejs koji klijent očekuje. On prilagođava nekompatibilne interfejse."
  },
  {
    "id": 78,
    "question": "Šta je Facade patern?",
    "answers": [
      "Konvertuje interfejs neke klase u drugi interfejs koji klijent očekuje. On prilagođava nekompatibilne interfejse.",
      "Definiše jedan-više zavisnost između objekata, tako da promena stanja nekog objekta utiče automatski na promenu stanja svih drugih objekata koji su povezani sa njim.",
      "Definiše kostur (skelet) algoritma u operaciji, prepuštajući definisanje nekih koraka potklasama. Template Method omogućava potklasama da redefinišu određene korake algoritma bez promene strukture algoritma.",
      "Obezbeđuje jedinstven interfejs za skup interfejsa nekog podsistema, definišući interfejs visokog nivoa koji omogućava lakše korišćenje podsistema."
    ],
    "correctAnswer": "Obezbeđuje jedinstven interfejs za skup interfejsa nekog podsistema, definišući interfejs visokog nivoa koji omogućava lakše korišćenje podsistema."
  },
  {
    "id": 79,
    "question": "Šta je Observer patern?",
    "answers": [
      "Konvertuje interfejs neke klase u drugi interfejs koji klijent očekuje. On prilagođava nekompatibilne interfejse.",
      "Obezbeđuje jedinstven interfejs za skup interfejsa nekog podsistema, definišući interfejs visokog nivoa koji omogućava lakše korišćenje podsistema.",
      "Modul treba da bude otvoren za proširenje, ali zatvoren za modifikaciju. (Open for extension, closed for modification).",
      "Definiše jedan-više zavisnost između objekata, tako da promena stanja nekog objekta utiče automatski na promenu stanja svih drugih objekata koji su povezani sa njim."
    ],
    "correctAnswer": "Definiše jedan-više zavisnost između objekata, tako da promena stanja nekog objekta utiče automatski na promenu stanja svih drugih objekata koji su povezani sa njim."
  }
]